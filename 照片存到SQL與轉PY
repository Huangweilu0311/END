import paho.mqtt.client as mqtt
import pymysql
import json
from datetime import datetime
import threading
import time
import base64
import os
import sys

# ---------- 資料庫設定 (請確保這些參數與您的 MySQL 伺服器設定完全一致) ----------
DB_CONFIG = {
    "host": "localhost",
    "user": "mqttuser",
    "password": "abc123",  # 請替換為您在 MySQL 中設定的密碼
    "database": "cam"      # 請確認資料庫名稱為 cam
}

# ---------- MQTT 設定 ----------
MQTT_BROKER = "broker.emqx.io"
MQTT_PORT = 1883

# 握手與 ACK Topics (必須與 ESP32 程式碼完全一致)
TOPIC_STATUS = "esp32/camera/status"       
TOPIC_CMD = "esp32/camera/cmd"           
TOPIC_CHUNK_ACK = "esp32/camera/chunk_ack" 

# 圖片資料 Topics
TOPIC_IMAGE_INFO = "esp32/camera/info"
TOPIC_IMAGE_DATA = "esp32/camera/data"
TOPIC_IMAGE_COMPLETE = "esp32/camera/complete"


# ---------- 資料庫操作 (同步執行 - 數據持久性優先) ----------
def insert_image_info(image_id, size, filename=None):
    """將圖片資訊寫入 cam_info (同步)"""
    conn = None
    try:
        conn = pymysql.connect(**DB_CONFIG)
        cursor = conn.cursor()
        ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
        sql = "INSERT INTO cam_info (timestamp, image_id, filename, size) VALUES (%s,%s,%s,%s)"
        cursor.execute(sql, (ts, image_id, filename, size))
        conn.commit()
        print(f"[DB] Image info saved: id={image_id}, size={size}")
    except Exception as e:
        # 如果寫入失敗，重新拋出異常，讓 on_message 處理
        raise Exception(f"Image info insert failed: {e}") 
    finally:
        if conn:
            conn.close()

def insert_image_chunk(image_id, chunk_index, total_chunks, data):
    """將 Base64 分段寫入 cam_data (同步)"""
    conn = None
    try:
        conn = pymysql.connect(**DB_CONFIG)
        cursor = conn.cursor()
        ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
        sql = "INSERT INTO cam_data (timestamp, image_id, chunk_index, total_chunks, data) VALUES (%s,%s,%s,%s,%s)"
        cursor.execute(sql, (ts, image_id, chunk_index, total_chunks, data))
        conn.commit()
        # print(f"[DB] Image chunk saved: id={image_id} chunk {chunk_index}/{total_chunks-1}") 
    except Exception as e:
        # 寫入失敗，重新拋出異常，讓 on_message 知道寫入失敗
        raise Exception(f"Image chunk insert failed (id={image_id} chunk={chunk_index}): {e}")
    finally:
        if conn:
            conn.close()

# ---------- MQTT 回呼 (數據持久性優先) ----------

def on_connect(client, userdata, flags, rc):
    print("MQTT connected with result code", rc)
    client.subscribe([(TOPIC_STATUS, 0), 
                      (TOPIC_IMAGE_INFO, 0), 
                      (TOPIC_IMAGE_DATA, 0), 
                      (TOPIC_IMAGE_COMPLETE, 0)])

def on_message(client, userdata, msg):
    """處理接收到的 MQTT 訊息 (同步執行資料庫操作)"""
    try:
        payload = msg.payload.decode()
        
        # --- 1. 處理握手啟動 ---
        if msg.topic == TOPIC_STATUS:
            if payload == "ESP32-CAM Online":
                print("\n[Status] ESP32-CAM is Online. Sending Handshake OK...")
                client.publish(TOPIC_CMD, "ok", qos=0) 
            return

        data = json.loads(payload)
        # print(f"Received topic: {msg.topic}, payload[:100]: {payload[:100]}...")

        # ---- 影像資訊 (同步寫入) ----
        if msg.topic == TOPIC_IMAGE_INFO:
            image_id = data.get("id")
            original_size = data.get("original_size")
            if image_id and original_size is not None:
                # 同步寫入 info
                insert_image_info(image_id, original_size)

        # ---- 分段資料 (核心傳輸 - 數據持久性優先) ----
        elif msg.topic == TOPIC_IMAGE_DATA:
            image_id = data.get("id")
            chunk_index = data.get("chunk")
            total_chunks = data.get("total")
            b64data = data.get("data")
            
            if None not in (image_id, chunk_index, total_chunks, b64data):
                
                # 執行同步寫入。如果失敗，將會拋出異常。
                insert_image_chunk(image_id, chunk_index, total_chunks, b64data)
                
                # 只有寫入成功，才發送 ACK
                client.publish(TOPIC_CHUNK_ACK, "CHUNK_ACK", qos=0) 
                print(f"Sent CHUNK_ACK for chunk {chunk_index}") 

        # ---- 完成訊息 ----
        elif msg.topic == TOPIC_IMAGE_COMPLETE:
            image_id = data.get("id")
            print(f"Image transfer complete for id={image_id}")

    except json.JSONDecodeError:
        print("Error: Failed to decode JSON payload")
    except Exception as e:
        # 捕獲所有異常，並輸出
        print(f"Error in on_message (Logic or DB Write): {e}")


# ---------- MQTT 啟動 (在背景執行緒中運行) ----------
def start_mqtt():
    # 使用預設版本 (v3.1.1)，避免版本錯誤。
    client = mqtt.Client(client_id="PythonReceiver", clean_session=True) 
    client.on_connect = on_connect
    client.on_message = on_message

    try:
        client.connect(MQTT_BROKER, MQTT_PORT, 60)
        client.loop_forever() # 保持連線
    except Exception as e:
        print(f"MQTT connection error: {e}")

# 啟動 MQTT 執行緒
mqtt_thread = threading.Thread(target=start_mqtt)
mqtt_thread.daemon = True
mqtt_thread.start()
print("MQTT client started in background, waiting for images...")

# ---------- 從資料庫還原完整圖片 (在主執行緒中運行) ----------
def restore_image(image_id, output_filename):
    """從資料庫中讀取所有分段並重組圖片"""
    conn = None
    try:
        conn = pymysql.connect(**DB_CONFIG)
        cursor = conn.cursor()
        
        # 查詢所有分段，按順序排列
        sql = "SELECT chunk_index, data FROM cam_data WHERE image_id=%s ORDER BY chunk_index ASC"
        cursor.execute(sql, (image_id,))
        rows = cursor.fetchall()
        
        if not rows:
            print(f"No data for image_id={image_id}")
            return
            
        # 1. 重組 Base64 字串
        full_b64 = "".join([row[1].strip() for row in rows])
        
        # 2. Base64 解碼為 JPEG 數據
        img_bytes = base64.b64decode(full_b64)
        
        # 3. 寫入圖片檔案
        with open(output_filename, "wb") as f:
            f.write(img_bytes)
            
        # 4. 更新 cam_info 檔案名稱紀錄
        cursor.execute("UPDATE cam_info SET filename=%s WHERE image_id=%s", (output_filename, image_id))
        conn.commit()
        
        print(f"Image restored successfully to {output_filename} ({len(img_bytes)} bytes)")
    except Exception as e:
        print(f"Restore image error: {e}")
    finally:
        if conn:
            conn.close()

# ---------- 主程式：互動還原迴圈 ----------
if __name__ == '__main__':
    try:
        while True:
            # 提示用戶輸入圖片 ID 進行還原
            restore_id = input("\n輸入 image_id 還原圖片 (或 Enter 跳過): ").strip()
            if restore_id:
                restore_image(restore_id, f"restored_{restore_id}.jpg")
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n程式結束")
        sys.exit()
