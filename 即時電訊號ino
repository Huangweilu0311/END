#include <WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>
#include "ADS1X15.h"

// ================= ä½¿ç”¨è€…è¨­å®šå€ =================
const char* ssid          = "LS Lab2";
const char* password      = "gs5g4432";
// âš ï¸ è«‹ç¢ºèªé€™æ˜¯æ‚¨é›»è…¦çš„ IP (åŸ·è¡Œ Python çš„é‚£å°)
const char* mqtt_server   = "192.168.1.24"; 
const int   mqtt_port     = 1883;
const char* data_topic    = "LS_Lab/sensor/adc/binary";

// ================= å€çŽ‡è¨­å®š =================
// ç›®æ¨™ï¼š12.6 mV -> 126 (å‚³é€æ•´æ•¸ä»¥ç¯€çœç©ºé–“ä¸¦ä¿æŒ 1 ä½å°æ•¸ç²¾åº¦)
const float SCALING_FACTOR = 10.0; 

// ================= ç‰©ä»¶å®£å‘Š =================
WiFiClient espClient;
PubSubClient client(espClient);
ADS1115 ADS(0x48);

// æ•¸æ“šçµæ§‹ (8 Bytes)
struct Sample {
  int32_t diff;    // æ”¾å¤§å¾Œçš„é›»å£“å€¼ (ä¾‹å¦‚ 126)
  uint32_t dt;     // è·é›¢ä¸Šæ¬¡æŽ¡æ¨£çš„æ™‚é–“å·® (us)
};

// æ‰¹æ¬¡èˆ‡ç·©è¡å€è¨­å®š
#define BATCH_SIZE 50 
#define PAYLOAD_BUFFER_SIZE 4096 

// FreeRTOS ä½‡åˆ—
QueueHandle_t sampleQueue;

// ================= WiFi é€£ç·š =================
void setup_wifi() {
  Serial.print("Connecting to WiFi");
  
  // ðŸ”¥ é—œéµï¼šé—œé–‰ WiFi ç¯€èƒ½æ¨¡å¼ï¼Œé˜²æ­¢å‚³è¼¸å¿½å¿«å¿½æ…¢
  WiFi.setSleep(false); 
  
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi Connected!");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

// ================= MQTT é‡é€£ =================
void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // ä½¿ç”¨éš¨æ©Ÿ ID é¿å…è¡çª
    String clientId = "ESP32-" + String(micros());
    if (client.connect(clientId.c_str())) {
      Serial.println("Connected!");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5s");
      delay(5000);
    }
  }
}

// ================= æ ¸å¿ƒä»»å‹™ï¼šADC æŽ¡æ¨£ (Core 0) =================
void TaskADC(void *pvParameters) {
  uint32_t lastMicros = micros();
  
  for (;;) {
    // 1. è®€å– ADC (åŒ…å« I2C é€šè¨Šæ™‚é–“)
    int16_t val = ADS.getValue();
    
    // 2. è¨ˆç®—ç²¾ç¢ºæ™‚é–“å·®
    uint32_t now = micros();
    uint32_t dt = now - lastMicros;
    lastMicros = now;

    // 3. é›»å£“è½‰æ›èˆ‡æ”¾å¤§ (å®šé»žæ•¸é‹ç®—)
    // ADS.toVoltage() å›žå‚³çš„æ˜¯ä¼ç‰¹ (V)ï¼Œå…ˆè½‰ mV å†æ”¾å¤§ 10 å€
    float voltage_mV = ADS.toVoltage(val) * 1000.0;
    
    Sample s;
    // ä¾‹å¦‚ï¼š12.6 mV * 10 = 126 (å­˜ç‚ºæ•´æ•¸)
    s.diff = (int32_t)(voltage_mV * SCALING_FACTOR); 
    s.dt = dt;

    // 4. æŽ¨é€åˆ°ä½‡åˆ—
    xQueueSend(sampleQueue, &s, 0);

    // 5. è®“å‡ºæ¥µå°‘è³‡æºçµ¦ç³»çµ± (é¿å… Watchdog è§¸ç™¼)
    taskYIELD(); 
  }
}

// ================= Setup åˆå§‹åŒ– =================
void setup() {
  Serial.begin(115200);
  
  // I2C è¨­å®šï¼šåŠ é€Ÿè‡³ 400kHz
  Wire.begin();
  Wire.setClock(400000); 

  // ADS1115 åˆå§‹åŒ–
  ADS.begin();
  ADS.setMode(0);      // é€£çºŒæ¨¡å¼
  ADS.setGain(16);     // +/- 0.256V
  ADS.setDataRate(7);  // æœ€å¿«æŽ¡æ¨£çŽ‡ (ç´„ 860 SPS)
  ADS.requestADC_Differential_0_1();

  setup_wifi();
  
  client.setServer(mqtt_server, mqtt_port);
  
  // ðŸ”¥ è¨­å®š 4KB ç·©è¡å€ä»¥å®¹ç´å¤§é‡æ•¸æ“š
  if (client.setBufferSize(PAYLOAD_BUFFER_SIZE)) {
      Serial.println("MQTT Buffer resized to 4096 bytes [OK]");
  } else {
      Serial.println("MQTT Buffer resize [FAILED]");
  }

  // å‰µå»ºä½‡åˆ— (å®¹é‡ 2500 ç­†ï¼Œç´„ 3-5 ç§’ç·©è¡)
  sampleQueue = xQueueCreate(2500, sizeof(Sample));

  // å•Ÿå‹• ADC ä»»å‹™æ–¼ Core 0
  xTaskCreatePinnedToCore(
    TaskADC,
    "ADC_Task",
    4096,    // å †ç–Šå¤§å°
    NULL,
    1,       // å„ªå…ˆç´š
    NULL,
    0        // æŒ‡å®š Core 0
  );
  
  Serial.println("System Started: Scaled x10 Mode");
}

// ================= Loop ä¸»è¿´åœˆ (Core 1) =================
void loop() {
  // è² è²¬ç¶²è·¯å‚³è¼¸
  if (!client.connected()) reconnect();
  client.loop();

  static Sample txBuffer[BATCH_SIZE];
  static int txIndex = 0;
  Sample s;

  // å¾žä½‡åˆ—å–å‡ºæ•¸æ“šä¸¦æ‰“åŒ…
  while (xQueueReceive(sampleQueue, &s, 0) == pdTRUE) {
    txBuffer[txIndex++] = s;

    // ç·©è¡å€æ»¿äº†å°±ç™¼é€
    if (txIndex >= BATCH_SIZE) {
      bool sent = client.publish(
        data_topic, 
        (const uint8_t*)txBuffer, 
        BATCH_SIZE * sizeof(Sample), 
        false
      );

      if (!sent) {
        Serial.println("Warning: Publish failed (Buffer full or Net slow)");
      }
      
      txIndex = 0;
    }
  }
}
