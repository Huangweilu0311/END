#include "esp_camera.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <Base64.h>
#include "esp_sleep.h"

// ---------- ESP32-CAM AI-Thinker GPIO (標準設定) ----------
#define PWDN_GPIO_NUM     32  // 改回 32 (因為沒有 DHT22 搶腳位了)
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
#define FLASH_LED_PIN      4

// ==========================================
// WiFi 與 MQTT 資訊 
// ==========================================
const char* ssid = "LS Lab2";          
const char* password = "gs5g4432";   

const char* mqtt_broker = "broker.emqx.io";   
const int mqtt_port = 1883;
const char* mqtt_username = "esp32cam_image"; 
const char* mqtt_password = "esp32cam_image"; 

// ---------- MQTT Topics ----------
const char* mqtt_topic_info = "LSLab_User_888/camera/info";
const char* mqtt_topic_data = "LSLab_User_888/camera/data";
const char* mqtt_topic_complete = "LSLab_User_888/camera/complete";
const char* mqtt_status_topic = "LSLab_User_888/camera/status";
const char* mqtt_cmd_topic = "LSLab_User_888/camera/cmd";       // 握手指令
const char* mqtt_chunk_ack = "LSLab_User_888/camera/chunk_ack"; // 分段確認

WiFiClient espClient;
PubSubClient mqtt_client(espClient);

// 拍照間隔（秒）
const unsigned long photoInterval = 300; // 5 分鐘

// 流程控制旗標與超時設定
volatile bool waitingForOK = false;
volatile bool chunkAckReceived = false;

const unsigned long okTimeout = 20000;    // 握手等待 20 秒
const unsigned long chunkTimeout = 5000;  // ACK 等待 5 秒
const int maxChunkRetries = 5; 
const int maxPhotoRetries = 3; 

// ------------------- 函數宣告 -------------------
void setupCamera();
void setupWiFi();
void connectToMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
bool sendImageChunks(String imageId, String &imageBase64);
bool captureAndSendPhoto();
void executePhotoTask();

// ------------------- 相機初始化 -------------------
void setupCamera() {
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sccb_sda = SIOD_GPIO_NUM;
    config.pin_sccb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
    
    // 使用 VGA 取得較好的平衡
    config.frame_size = FRAMESIZE_VGA; 
    config.jpeg_quality = 25;
    config.fb_count = 2; 
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
    
    if (esp_camera_init(&config) != ESP_OK) {
        Serial.println("Camera init failed!");
        return; 
    }
    
    // 感測器參數調整
    sensor_t * s = esp_camera_sensor_get();
    if (s) {
        s->set_whitebal(s, 1);    
        s->set_awb_gain(s, 1);    
        s->set_wb_mode(s, 0);      
        s->set_exposure_ctrl(s, 1); 
        s->set_aec2(s, 0);          
        s->set_ae_level(s, 0);      
        s->set_gain_ctrl(s, 1);     
        s->set_bpc(s, 0);            
        s->set_wpc(s, 1);            
        s->set_raw_gma(s, 1);        
        s->set_lenc(s, 1);           
        s->set_dcw(s, 1);            
        s->set_vflip(s, 0);          
        s->set_hmirror(s, 0);        
    }
    Serial.println("Camera configured.");
}

// ------------------- Wi-Fi 連線 -------------------
void setupWiFi() {
    if (WiFi.status() == WL_CONNECTED) return;
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting Wi-Fi...");
    unsigned long start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
        delay(500);
        Serial.print(".");
    }
    Serial.println(WiFi.status() == WL_CONNECTED ? "\nWi-Fi connected!" : "\nWi-Fi failed!");
}

// ------------------- MQTT 回調函數 -------------------
void mqttCallback(char* topic, byte* payload, unsigned int length) {
    String msg;
    for (int i = 0; i < length; i++) msg += (char)payload[i];
    
    // 收到 "ok" 代表握手成功
    if (String(topic) == mqtt_cmd_topic && msg == "ok") {
        waitingForOK = false; 
        Serial.println("[MQTT] Handshake OK! Server is ready.");
    }
    
    // 收到分段確認
    if (String(topic) == mqtt_chunk_ack && msg == "CHUNK_ACK") {
        chunkAckReceived = true;
    }
}

// ------------------- MQTT 連線 (關鍵順序修正) -------------------
void connectToMQTT() {
    mqtt_client.setServer(mqtt_broker, mqtt_port);
    mqtt_client.setCallback(mqttCallback);
    mqtt_client.setBufferSize(8192); 
    
    if (mqtt_client.connected()) return;

    unsigned long start = millis();
    while (!mqtt_client.connected() && millis() - start < 15000) {
        String clientId = "ESP32CAM-" + String(random(0xffff), HEX);
        Serial.print("Connecting MQTT...");
        
        // 1. 建立連線
        if (mqtt_client.connect(clientId.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("Connected!");
            
            // ★★★ 2. 連線後，第一件事：訂閱 (Subscribe) ★★★
            // 先確保耳朵打開，才能聽到 Server 回傳的 ok
            mqtt_client.subscribe(mqtt_cmd_topic);
            mqtt_client.subscribe(mqtt_chunk_ack); 
            
            return;
        } else {
            Serial.print("failed, rc="); Serial.println(mqtt_client.state());
            delay(2000);
        }
    }
}

// ------------------- 分段傳送邏輯 -------------------
bool sendImageChunks(String imageId, String &imageBase64) {
    const int maxChunkSize = 1000; 
    int totalChunks = (imageBase64.length() + maxChunkSize - 1) / maxChunkSize;

    Serial.printf("Sending image %s in %d chunks...\n", imageId.c_str(), totalChunks);

    for (int i = 0; i < totalChunks; i++) {
        int currentRetries = 0;
        bool chunkSent = false;
        
        int startPos = i * maxChunkSize;
        int chunkSize = min(maxChunkSize, (int)(imageBase64.length() - startPos));
        String chunk = imageBase64.substring(startPos, startPos + chunkSize);
        
        const int JSON_MAX_SIZE = 2000; 
        char chunkJson[JSON_MAX_SIZE];
        snprintf(chunkJson, JSON_MAX_SIZE, 
                 "{\"id\":\"%s\",\"chunk\":%d,\"total\":%d,\"data\":\"%s\"}", 
                 imageId.c_str(), i, totalChunks, chunk.c_str());

        while (currentRetries < maxChunkRetries && !chunkSent) {
            if (mqtt_client.publish(mqtt_topic_data, chunkJson, false)) {
                chunkAckReceived = false;
                unsigned long chunkWaitStart = millis();
                
                // 等待 ACK
                while (!chunkAckReceived && millis() - chunkWaitStart < chunkTimeout) {
                    mqtt_client.loop(); 
                    delay(10);
                }
                if (chunkAckReceived) chunkSent = true;
                else { currentRetries++; Serial.print("x"); }
            } else {
                if (!mqtt_client.connected()) connectToMQTT();
                currentRetries++;
                delay(100);
            }
        }
        
        if (!chunkSent) {
            Serial.println("\nChunk failed. Abort.");
            return false;
        }
        Serial.print(".");
    }

    // 發送完成訊號
    String completeMsg = "{\"id\":\"" + imageId + "\"}";
    mqtt_client.publish(mqtt_topic_complete, completeMsg.c_str(), true); 
    return true; 
}

// ------------------- 拍照並傳送 -------------------
bool captureAndSendPhoto() {
    Serial.println("\nWarming up camera...");
    pinMode(FLASH_LED_PIN, OUTPUT);
    digitalWrite(FLASH_LED_PIN, HIGH); // 需要補光請取消註解
    
    // 暖機：丟棄前兩張以穩定白平衡
    for (int i = 0; i < 2; i++) {
        camera_fb_t * temp = esp_camera_fb_get();
        if (temp) esp_camera_fb_return(temp);
        delay(100);
    }

    Serial.println("Taking photo...");
    camera_fb_t * fb = esp_camera_fb_get();
    // digitalWrite(FLASH_LED_PIN, LOW); // 關燈

    if (!fb) {
        Serial.println("Capture failed!");
        return false;
    }

    String imageId = String(millis()) + "_" + String(random(1000));
    String imageBase64 = base64::encode(fb->buf, fb->len);

    String info = "{\"id\":\"" + imageId + "\",\"original_size\":" + String(fb->len) + "}";
    mqtt_client.publish(mqtt_topic_info, info.c_str(), true);
    
    bool success = sendImageChunks(imageId, imageBase64);
    esp_camera_fb_return(fb);
    return success;
}

// ------------------- 任務執行 (核心邏輯) -------------------
void executePhotoTask() {
    setupWiFi();
    connectToMQTT(); // 這裡內部已經執行 Subscribe

    if (WiFi.status() != WL_CONNECTED || !mqtt_client.connected()) return;

    bool taskDone = false;
    int retries = 0;
    
    while (!taskDone && retries < maxPhotoRetries) {
        
        Serial.println("Initiating Handshake...");
        waitingForOK = true; 
        
        // ★★★ 3. 訂閱完成後，才發送上線通知 (Publish) ★★★
        mqtt_client.publish(mqtt_status_topic, "ESP32-CAM Online", false);
        
        unsigned long waitStart = millis();
        Serial.println("Waiting for server ACK (ok)...");
        
        // ★★★ 4. 關鍵迴圈：等待回應時必須保持 loop() ★★★
        while (waitingForOK && millis() - waitStart < okTimeout) {
            mqtt_client.loop(); // 持續監聽 MQTT 訊息
            delay(10);
        }

        if (!waitingForOK) { 
            // waitingForOK 變成 false 代表收到 "ok" 了
            Serial.println("Handshake successful. Starting transmission.");
            taskDone = captureAndSendPhoto(); 
        } else {
            Serial.println("Handshake Timeout. Server didn't reply 'ok'. Retrying...");
            retries++;
            delay(2000);
        }
    }

    Serial.println(taskDone ? "Task Finished." : "Task Failed.");
}

// ------------------- Setup -------------------
void setup() {
    Serial.begin(115200);
    Serial.println("\n--- Boot (Camera Only) ---"); 
    
    setupCamera(); 
    
    // 執行一次完整的拍照任務
    executePhotoTask();

    Serial.printf("Sleep %lu s\n", photoInterval);
    esp_sleep_enable_timer_wakeup(photoInterval * 1000000ULL);
    Serial.flush();
    esp_deep_sleep_start();
}

void loop() {}
