#include "esp_camera.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <Base64.h>
#include "esp_sleep.h"

// ---------- ESP32-CAM AI-Thinker GPIO ----------
#define PWDN_GPIO_NUM       32
#define RESET_GPIO_NUM      -1
#define XCLK_GPIO_NUM       0
#define SIOD_GPIO_NUM       26
#define SIOC_GPIO_NUM       27
#define Y9_GPIO_NUM         35
#define Y8_GPIO_NUM         34
#define Y7_GPIO_NUM         39
#define Y6_GPIO_NUM         36
#define Y5_GPIO_NUM         21
#define Y4_GPIO_NUM         19
#define Y3_GPIO_NUM         18
#define Y2_GPIO_NUM         5
#define VSYNC_GPIO_NUM      25
#define HREF_GPIO_NUM       23
#define PCLK_GPIO_NUM       22
#define FLASH_LED_PIN       4

// ==========================================
// è«‹åœ¨æ­¤è™•å¡«å¯«æ‚¨çš„ WiFi èˆ‡ MQTT è³‡è¨Š 

// ==========================================
const char* ssid = "LS Lab2";          // è«‹ä¿®æ”¹
const char* password = "gs5g4432";  // è«‹ä¿®æ”¹

const char* mqtt_broker = "broker.emqx.io";   // è«‹ä¿®æ”¹
const int mqtt_port = 1883;
const char* mqtt_username = "esp32cam_image"; // è«‹ä¿®æ”¹
const char* mqtt_password = "esp32cam_image"; // è«‹ä¿®æ”¹

// ---------- MQTT Topics ----------
const char* mqtt_topic_info = "esp32/camera/info";
const char* mqtt_topic_data = "esp32/camera/data";
const char* mqtt_topic_complete = "esp32/camera/complete";
const char* mqtt_status_topic = "esp32/camera/status";
const char* mqtt_cmd_topic = "esp32/camera/cmd";       // æ¡æ‰‹æŒ‡ä»¤
const char* mqtt_chunk_ack = "esp32/camera/chunk_ack"; // åˆ†æ®µç¢ºèª

WiFiClient espClient;
PubSubClient mqtt_client(espClient);

// æ‹ç…§é–“éš”ï¼ˆç§’ï¼‰
const unsigned long photoInterval = 600; // 10 åˆ†é˜

// æµç¨‹æŽ§åˆ¶æ——æ¨™èˆ‡è¶…æ™‚è¨­å®š
bool waitingForOK = false;
unsigned long okWaitStart = 0;
const unsigned long okTimeout = 45000; // æ¡æ‰‹è¶…æ™‚

volatile bool chunkAckReceived = false;
const unsigned long chunkTimeout = 10000; // ACK è¶…æ™‚
const int maxChunkRetries = 5; 
const int maxPhotoRetries = 3; 

// ------------------- å‡½æ•¸å®£å‘Š -------------------
void setupCamera();
void setupWiFi();
void connectToMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
bool sendImageChunks(String imageId, String &imageBase64);
bool captureAndSendPhoto();
void executePhotoTask();


// ------------------- ç›¸æ©Ÿåˆå§‹åŒ–èˆ‡é…ç½® -------------------
void setupCamera() {
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM; 
    config.pin_d1 = Y3_GPIO_NUM; 
    config.pin_d2 = Y4_GPIO_NUM; 
    config.pin_d3 = Y5_GPIO_NUM; 
    config.pin_d4 = Y6_GPIO_NUM; 
    config.pin_d5 = Y7_GPIO_NUM; 
    config.pin_d6 = Y8_GPIO_NUM; 
    config.pin_d7 = Y9_GPIO_NUM; 
    config.pin_xclk = XCLK_GPIO_NUM; 
    config.pin_pclk = PCLK_GPIO_NUM; 
    config.pin_vsync = VSYNC_GPIO_NUM; 
    config.pin_href = HREF_GPIO_NUM; 
    config.pin_sccb_sda = SIOD_GPIO_NUM; 
    config.pin_sccb_scl = SIOC_GPIO_NUM; 
    config.pin_pwdn = PWDN_GPIO_NUM; 
    config.pin_reset = RESET_GPIO_NUM; 
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
    
    // è§£æžåº¦è¨­å®šï¼šä½¿ç”¨ VGA (640x480) å¹³è¡¡ç•«è³ªèˆ‡å‚³è¼¸ç©©å®šæ€§
    // è‹¥ä½¿ç”¨ QVGA (320x240) é›–ç„¶èˆ‡æˆªåœ–ç›¸åŒï¼Œä½†ç•«é¢å¤ªå°ä¸å¯¦ç”¨
    config.frame_size = FRAMESIZE_VGA; 
    
    // ç•«è³ªè¨­å®šï¼šä¿æŒ 20 ä»¥ç¢ºä¿ MQTT ä¸æœƒå› ç‚ºå°åŒ…éŽå¤§è€Œå¤±æ•—
    // (æˆªåœ–ä¸­çš„ Quality 4 æª”æ¡ˆéŽå¤§ï¼Œä¸é©åˆ MQTT)
    config.jpeg_quality = 30;
    
    config.fb_count = 2; // é›™ç·©è¡å€
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
    
    if (!psramFound()) {
        config.frame_size = FRAMESIZE_QVGA;
        config.fb_location = CAMERA_FB_IN_DRAM;
    }

    // åŸ·è¡Œåˆå§‹åŒ–
    if (esp_camera_init(&config) != ESP_OK) {
        Serial.println("Camera init failed!");
        return; 
    }
    
    // =========================================================
    // ðŸ“· å‚³æ„Ÿå™¨åƒæ•¸è¨­å®š (å®Œå…¨ä¾ç…§æ‚¨çš„ CameraWebServer æˆªåœ–è¨­å®š)
    // =========================================================
    Serial.println("Camera initialized! Applying settings from screenshot...");

    sensor_t * s = esp_camera_sensor_get();
    if (s) {
        // 1. åŸºç¤Žè‰²å½© (æˆªåœ–çš†ç‚º 0)
        s->set_brightness(s, 0);
        s->set_contrast(s, 0);
        s->set_saturation(s, 0);
        s->set_special_effect(s, 0); // No Effect

        // 2. è‡ªå‹•ç™½å¹³è¡¡ (æˆªåœ–: AWB=ON, AWB Gain=ON, Mode=Auto)
        s->set_whitebal(s, 1);    // å•Ÿç”¨è‡ªå‹•ç™½å¹³è¡¡
        s->set_awb_gain(s, 1);    // å•Ÿç”¨ç™½å¹³è¡¡å¢žç›Š
        s->set_wb_mode(s, 0);     // 0 = Auto

        // 3. è‡ªå‹•æ›å…‰èˆ‡å¢žç›Š (æˆªåœ–: AEC SENSOR=ON, AE Level=0, AGC=ON)
        s->set_exposure_ctrl(s, 1); // å•Ÿç”¨è‡ªå‹•æ›å…‰
        s->set_aec2(s, 0);          // æˆªåœ–ä¸­ AEC DSP æ˜¯é—œé–‰çš„
        s->set_ae_level(s, 0);      // æ›å…‰è£œå„Ÿ 0
        s->set_gain_ctrl(s, 1);     // å•Ÿç”¨è‡ªå‹•å¢žç›Š

        // 4. é€²éšŽå½±åƒè™•ç† (ä¾ç…§æˆªåœ–é–‹é—œ)
        s->set_bpc(s, 0);           // BPC é—œé–‰
        s->set_wpc(s, 1);           // WPC é–‹å•Ÿ (å£žé»žä¿®æ­£)
        s->set_raw_gma(s, 1);       // Raw GMA é–‹å•Ÿ (Gamma æ ¡æ­£)
        s->set_lenc(s, 1);          // Lens Correction é–‹å•Ÿ (é¡é ­æ ¡æ­£)
        s->set_dcw(s, 1);           // DCW é–‹å•Ÿ (ç¸®æ”¾æ¼”ç®—æ³•)

        // 5. æ–¹å‘è¨­å®š (æˆªåœ–ä¸­ V-Flip æ˜¯é—œé–‰çš„)
        s->set_vflip(s, 0);         
        s->set_hmirror(s, 0);       

        // ç‰¹æ®Šä¿®æ­£ï¼šå¦‚æžœæ˜¯ OV3660 å‚³æ„Ÿå™¨ï¼Œé€šå¸¸ç‰©ç†ä¸Šéœ€è¦ç¿»è½‰
        if (s->id.PID == OV3660_PID) {
             s->set_vflip(s, 1);
        }

        Serial.println("Sensor configuration complete (Auto Mode).");
    }
}

// ------------------- Wi-Fi é€£ç·š -------------------
void setupWiFi() {
    if (WiFi.status() == WL_CONNECTED) return;
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting Wi-Fi...");
    unsigned long start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
        delay(500);
        Serial.print(".");
    }
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nWi-Fi connected!");
    } else {
        Serial.println("\nWi-Fi connect failed!");
    }
}

// ------------------- MQTT å›žèª¿å‡½æ•¸ -------------------
void mqttCallback(char* topic, byte* payload, unsigned int length) {
    String msg;
    for (int i = 0; i < length; i++) msg += (char)payload[i];
    
    // è™•ç†æ¡æ‰‹ç¢ºèª
    if (String(topic) == mqtt_cmd_topic && msg == "ok") {
        waitingForOK = false;
        Serial.println("Received OK from Python!");
    }
    
    // è™•ç†åˆ†æ®µç¢ºèª
    if (String(topic) == mqtt_chunk_ack && msg == "CHUNK_ACK") {
        chunkAckReceived = true;
    }
}

// ------------------- MQTT é€£ç·šèˆ‡è¨‚é–± -------------------
void connectToMQTT() {
    mqtt_client.setServer(mqtt_broker, mqtt_port);
    mqtt_client.setCallback(mqttCallback);
    mqtt_client.setBufferSize(8192); // åŠ å¤§ç·©è¡å€
    
    if (mqtt_client.connected()) return;

    unsigned long start = millis();
    while (!mqtt_client.connected() && millis() - start < 15000) {
        String clientId = "ESP32CAM-" + String(random(0xffff), HEX);
        Serial.print("Connecting MQTT...");
        if (mqtt_client.connect(clientId.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("Connected!");
            
            // ç™¼é€ä¸Šç·šç‹€æ…‹
            mqtt_client.publish(mqtt_status_topic, "ESP32-CAM Online", true); 
            
            mqtt_client.subscribe(mqtt_cmd_topic);
            mqtt_client.subscribe(mqtt_chunk_ack); 
            return;
        } else {
            Serial.print("failed, rc="); Serial.println(mqtt_client.state());
            delay(2000);
        }
    }
}

// ------------------- åˆ†æ®µå‚³é€èˆ‡é‡è©¦ -------------------
bool sendImageChunks(String imageId, String &imageBase64) {
    const int maxChunkSize = 700; // æ¯å€‹åˆ†æ®µå¤§å°
    int totalChunks = (imageBase64.length() + maxChunkSize - 1) / maxChunkSize;

    Serial.printf("Sending image %s in %d chunks...\n", imageId.c_str(), totalChunks);

    for (int i = 0; i < totalChunks; i++) {
        int currentRetries = 0;
        bool chunkSent = false;
        
        int startPos = i * maxChunkSize;
        int chunkSize = min(maxChunkSize, (int)(imageBase64.length() - startPos));
        String chunk = imageBase64.substring(startPos, startPos + chunkSize);
        
        // æ§‹å»º JSON 
        const int JSON_MAX_SIZE = 1200; 
        char chunkJson[JSON_MAX_SIZE];
        snprintf(chunkJson, JSON_MAX_SIZE, 
                 "{\"id\":\"%s\",\"chunk\":%d,\"total\":%d,\"data\":\"%s\"}", 
                 imageId.c_str(), i, totalChunks, chunk.c_str());

        while (currentRetries < maxChunkRetries && !chunkSent) {
            // ç™¼é€
            if (mqtt_client.publish(mqtt_topic_data, chunkJson, false)) {
                // ç­‰å¾… ACK
                chunkAckReceived = false;
                unsigned long chunkWaitStart = millis();
                while (!chunkAckReceived && millis() - chunkWaitStart < chunkTimeout) {
                    mqtt_client.loop(); 
                    delay(10);
                }
                if (chunkAckReceived) {
                    chunkSent = true;
                } else {
                    currentRetries++;
                    Serial.printf("Chunk %d ACK timeout. Retrying...\n", i);
                }
            } else {
                if (!mqtt_client.connected()) connectToMQTT();
                currentRetries++;
                delay(100);
            }
        }
        
        if (!chunkSent) {
            Serial.println("FATAL: Chunk transfer failed.");
            return false;
        }
    }

    // ç™¼é€å®Œæˆè¨Šè™Ÿ
    String completeMsg = "{\"id\":\"" + imageId + "\",\"status\":\"complete\",\"chunks\":" + String(totalChunks) + "}";
    mqtt_client.publish(mqtt_topic_complete, completeMsg.c_str(), true); 
    mqtt_client.loop();
    
    return true; 
}

// ------------------- æ‹ç…§ä¸¦å‚³é€ (ä¿®æ­£ç‰ˆï¼šåŠ å…¥æš–æ©Ÿ) -------------------
bool captureAndSendPhoto() {
    Serial.println("Preparing to take photo...");
    
    // 1. é–‹å•Ÿé–ƒå…‰ç‡ˆ
    pinMode(FLASH_LED_PIN, OUTPUT);
    digitalWrite(FLASH_LED_PIN, HIGH);
    
    // 2. é—œéµä¿®æ­£ï¼šæš–æ©Ÿæµç¨‹ (Warm-up)
    // è®“ç›¸æ©Ÿé€£çºŒæŠ“å–ä¸¦ä¸Ÿæ£„å‰å¹¾å¹€ç•«é¢ï¼Œè®“ AWB (ç™½å¹³è¡¡) å’Œ AEC (æ›å…‰) æœ‰æ™‚é–“æ”¶æ–‚
   
    Serial.print("Warming up camera...");
    for (int i = 0; i < 2; i++) {
        camera_fb_t * temp_fb = esp_camera_fb_get();
        if (temp_fb) {
            esp_camera_fb_return(temp_fb); // è®€å–å¾Œé¦¬ä¸Šé‡‹æ”¾ï¼Œä¸å‚³é€
            delay(100);
            Serial.print(".");
        }
        delay(80); // ç¨å¾®é–“éš”ï¼Œçµ¦æ„Ÿå…‰å…ƒä»¶é‹ç®—æ™‚é–“
    }
    Serial.println(" Done!");

    // 3. æ‹æ”çœŸæ­£è¦å‚³é€çš„ç…§ç‰‡
    Serial.println("Taking FINAL photo...");
    camera_fb_t * fb = esp_camera_fb_get();
    
    // æ‹ç…§å®Œæˆï¼Œç«‹åˆ»é—œç‡ˆ (çœé›»)
    digitalWrite(FLASH_LED_PIN, LOW);

    if (!fb) {
        Serial.println("Camera capture failed!");
        return false;
    }

    // --- ä»¥ä¸‹ä¿æŒåŽŸæœ¬çš„å‚³é€é‚è¼¯ ---
    String imageId = String(millis()) + "_" + String(random(1000));
    String imageBase64 = base64::encode(fb->buf, fb->len);

    String info = "{\"id\":\"" + imageId + "\",\"timestamp\":" + String(millis()) +
                  ",\"original_size\":" + String(fb->len) +
                  ",\"base64_size\":" + String(imageBase64.length()) +
                  ",\"format\":\"jpeg\",\"encoding\":\"base64\"}";

    mqtt_client.publish(mqtt_topic_info, info.c_str(), true);
    mqtt_client.loop();

    bool transferSuccess = sendImageChunks(imageId, imageBase64);
    
    esp_camera_fb_return(fb); // é‡‹æ”¾è¨˜æ†¶é«”
    return transferSuccess;
}
// ------------------- ä»»å‹™åŸ·è¡Œè€… -------------------
void executePhotoTask() {
    setupWiFi();
    connectToMQTT();

    if (WiFi.status() != WL_CONNECTED || !mqtt_client.connected()) {
        Serial.println("Network failed. Skipping task.");
        return;
    }

    bool photoTaskSucceeded = false;
    int currentPhotoRetries = 0;
    
    while (!photoTaskSucceeded && currentPhotoRetries < maxPhotoRetries) {
        // ç™¼é€ç‹€æ…‹ä¸¦ç­‰å¾… Python ç«¯å›žæ‡‰ OK (æ¡æ‰‹)
        waitingForOK = true;
        mqtt_client.publish(mqtt_status_topic, "ESP32-CAM Online", true);
        
        unsigned long okWaitStart = millis();
        Serial.println("Waiting for Handshake...");
        
        while (waitingForOK && millis() - okWaitStart < okTimeout) {
            mqtt_client.loop();
            delay(10);
        }

        if (!waitingForOK) { 
            photoTaskSucceeded = captureAndSendPhoto(); 
        } else {
            Serial.println("Handshake timeout.");
        }
        
        if (!photoTaskSucceeded) {
            currentPhotoRetries++;
            delay(2000);
        }
    }

    if (photoTaskSucceeded) Serial.println("--- Task SUCCESS ---");
    else Serial.println("--- Task FAILED ---");
}

// ------------------- Setup -------------------
void setup() {
    Serial.begin(115200);
    Serial.println("--- Starting Setup ---"); 
    randomSeed(analogRead(0)); 
    
    setupCamera(); // è¨­å®šç›¸æ©Ÿåƒæ•¸
    
    // åŸ·è¡Œä¸€æ¬¡ä»»å‹™
    executePhotoTask();

    // é€²å…¥ç¡çœ 
    Serial.printf("Sleeping for %lu seconds...\n", photoInterval);
    esp_sleep_enable_timer_wakeup(photoInterval * 1000000ULL);
    delay(100);
    esp_deep_sleep_start(); // æ”¹ç”¨ Deep Sleep æ›´çœé›»ï¼Œé†’ä¾†æœƒé‡è·‘ setup
}

void loop() {
    // Deep Sleep æ¨¡å¼ä¸‹ä¸æœƒåŸ·è¡Œåˆ°é€™è£¡
}
